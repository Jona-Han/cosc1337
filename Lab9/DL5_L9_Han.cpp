/*
  Author:                      Jonathan Han
  Assignment Number:           Lab 9
  File Name:                   DL5_L9_Lastname.cpp
  Course/Section:              COSC 1337 Section 5
  Instructor:                  Thayer
*/

/*
Lab Ch09
  To find places to add code, search on "<add code>"
  To find places to change code, search on "<change code>"
  To find either places, search on "code>"
*/

#include <iostream>
#include <iomanip>
#include <random> // needed for Orwell devcpp

using namespace std;

// The searching and sorting algorithms will be tested on a big array filled with random numbers.
// To test on various array sizes, increasing amounts of the big array will be used.
// A table will display results of how long it takes to complete a task on various sizes of test data.
const int BIGSIZE = 64000;
int bigArray[BIGSIZE];
const int testSizes[] = {1000, 2000, 4000, 8000, 16000, 32000, BIGSIZE, 0}; // 0 is a sentinel
// All numbers inside testSizes MUST BE less than or equal to BIGSIZE

const int TARGET = 123456789; // TARGET is uses as a number to search for.
// TARGET cannot be found. It is larger than any random number
// generated by rand(), as desired to test for worst-case performance of search.

// array helper functions:
void showArray(int array[], int size, const string &msg="") { // displays every element in array
    cout<<msg;
    for (int i{}; i<size; ++i)
        cout << setw(2) << array[i]; // assumes small numbers
    cout << endl;
}

// Useful to verify that array is really sorted!
bool verifySorted(int array[], int size) {
    // returns true if array is in ascending order, else false.
    for (int i=0; i<(size-1); ++i)
        if (array[i]>array[i+1]) return false;
    return true;
}


// Useful to measure unsorted-ness of the array
int unorderedCount(int array[], int size) {
    // returns count of out of order adjacent pairs.
    int unsorted_adjacent_pairs{};
    for (int i=0; i<(size-1); ++i)
        if (array[i]>array[i+1]) ++unsorted_adjacent_pairs;
    return unsorted_adjacent_pairs;
}

// To display the table of timing results, use these to set column widths:
const int AlgorithmNameMaxWidth=16; // maximum column width to display algorithm names
const int TestSizeWidth=12;         // maximum column width to display time to run algorithms
const int DurationWidth=TestSizeWidth;
// Adjust these column widths if/as needed so the table columns are aligned.

// Each selection sort below does the same algorithm. The difference is in
// how well it documents its operation. See code after main.
const string SELECTION_SORT_NAME{"selection sort"};
void selectionSortConcise(int[], int);   // from internet, not called
void selectionSortTextBook(int[], int);  // from our textbook, not called
void selectionSort(int[], int, bool);    // as expected for this lab

// <change code> Change "mySort1", "mySort2" to better names that match sort algorithm
const string SORT1_NAME {"bubble sort"};
void bubbleSort(int[], int, bool);    // expected for this lab <change code>

const string SORT2_NAME {"insertion sort"};
void insertionSort(int[], int, bool);    // expected for this lab <change code>

bool linearSearchArray(int [], int, int, int&); // provided
bool binarySearchArray(int [], int, int, int&); // expected for this lab <change code>

// This code helps to automate multiple test runs.

// Call this code as many times as desired to test your sort algorithms.
float testSortAlgorithm1x(void sortAlgorithm(int [], int, bool),
                          int array[], int arraySize, bool verbose=false) {
    // Run sortAlgorithm once on array and return time elapsed in milliseconds.
    // This function is interesting. The first parameter is a "function pointer",
    // It accepts any function that returns a void and has parameters of type: (int [], int, bool)
    // The first parameter (in the caller) can be the name of a function being tested.
    // This reduces redundant code. The same sequence of tests are performed on each
    // sort function. (Our textbook does not mention function pointers.)

    // fill array with random, unsorted numbers to be sorted
    for (int index = 0; index < arraySize; index++)
        array[index] = rand();  // initialize array with random values
    int startTime = clock();  // get the start time, in milliseconds
    sortAlgorithm(array, arraySize, verbose);  // ALGORITHM UNDER TEST
    int stopTime = clock();   // get the stop time, in milliseconds
    float duration = stopTime - startTime;

    int unordered_pairs = unorderedCount(array, arraySize);
    if (unordered_pairs != 0)
        return -unordered_pairs; // return a negative count of unordered pairs to indicate sort failure
    else
        return duration;
}

void testSortAlgorithmNx(void sortAlgorithm(int [], int, bool), string sortName,
                         int array[], int arraySize, bool verbose=false) {
    // call testSortAlgorithm1x for each size in testSizes; display results on one line of table
    cout << endl << setw (AlgorithmNameMaxWidth) << left << sortName;
    for (int testCount=0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
        cout << setw(DurationWidth) << right << testSortAlgorithm1x(sortAlgorithm, array, testSizes[testCount]);
}


// Copy/paste/modify/reuse this code as desired to test search algorithms.
// Because search is much faster than sort and duration is in milliseconds,
// the search is run retry times (defaults to 1000) and duration is divided by retry.
float testLinearSearch(int array[], int arraySize, int retry=1000) {
    bool found = false; // true if TARGET is found in array
    int foundAt = -1;    // index in array where TARGET was found
    int startTime = clock();
    for (int repeat = 0; repeat < retry; ++repeat) // repeat test 1000 times to increase duration
        found = linearSearchArray(array, arraySize, TARGET, foundAt); // ALGORITHM UNDER TEST
    int stopTime = clock();
    float duration = stopTime - startTime;
    return duration/retry; // divide duration by 1000 to get time for single search
}

// <add code> to test binary search. It works like testLinearSearch
float testBinarySearch(int array[], int arraySize, int retry=1000) {
    bool found = false; // true if TARGET is found in array
    int foundAt = -1;    // index in array where TARGET was found
    int startTime = clock();
    for (int repeat = 0; repeat < retry; ++repeat) // repeat test 100000 times to increase duration
        found = binarySearchArray(array, arraySize, TARGET, foundAt); // ALGORITHM UNDER TEST
    int stopTime = clock();
    float duration = stopTime - startTime;
    return duration/retry;
}

void testAlgorithms(int array[], int arraySize, bool verbose=false) {
    // This draws a table of results for each algorithm tested.
    // Initially, the heading for the table is displayed:
    cout << setw (AlgorithmNameMaxWidth) << left << "Algorithm";
    for (int testCount=0; testSizes[testCount]; ++testCount)
        cout << setw(TestSizeWidth) << right << testSizes[testCount];
    cout << endl << string(AlgorithmNameMaxWidth, '=');
    for (int testCount=0; testSizes[testCount]; ++testCount)
        cout << setw(DurationWidth) << right << " =======";

    // In testSortAlgorithmNx, the name of the sort function is passed as a parameter.
    // Do the same thing for your sort algorithms. It works as long as your sort algorithm
    // returns void and is declared as: void sort(int array[], int size).

    testSortAlgorithmNx(selectionSort, SELECTION_SORT_NAME, array, arraySize); // provided
    // call to test your first sort algorithm. <change code> rename my sort 1
    testSortAlgorithmNx(bubbleSort, SORT1_NAME, array, arraySize);
    // call to test your second sort algorithm. <change code> rename my sort 2
    testSortAlgorithmNx(insertionSort, SORT2_NAME, array, arraySize);

    cout<<"\n--------"; // separator between sort algorithms and search algorithms

    // Here, the provided linear search is tested...
    cout << endl << setw (AlgorithmNameMaxWidth) << left << "linear search";
    for (int testCount=0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
        cout << setw(DurationWidth) << right << testLinearSearch(array, testSizes[testCount]);

    // <change code> Use a loop to call and test your search algorithm here

    cout << endl << setw (AlgorithmNameMaxWidth) << left << "binary search";
    for (int testCount=0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
        cout << setw(DurationWidth) << right << testBinarySearch(array, testSizes[testCount]);
    cout << endl;
}


void testSortOnSmallArray(void sortAlgorithm(int [], int, bool), string sortName) {
    int smallArray[] {7, 9, 3, 1, 8, 6, 2}; // for testing purposes

    const int SMALLSIZE = sizeof(smallArray)/sizeof(smallArray[0]);

    showArray(smallArray, SMALLSIZE, sortName + " start: smallArray is: ");
    sortAlgorithm(smallArray, SMALLSIZE, true); // true means verbose, show details
    showArray(smallArray, SMALLSIZE, sortName + " stop:  smallArray is: ");
    cout << ((verifySorted(smallArray, SMALLSIZE)) ?
             "Verified: smallArray is sorted.\n\n" :
             "Oops!!!: smallArray is NOT sorted.\n\n");
}

int main () {
    srand(time(0));  // seed the random number generator only once.

    // When first implementing your algorithm, test it on a very small array.
    // The verbose flag will be set to true in testSortOnSmallArray, so step-by-step
    // progress will be displayed. This describes how the sort is working.

    cout << "Test sorting algorithms on small array:\n\n";
    // testSortOnSmallArray provides a small array to test on and sets verbose=true
    testSortOnSmallArray(selectionSort, SELECTION_SORT_NAME);
    testSortOnSmallArray(bubbleSort, SORT1_NAME);
    testSortOnSmallArray(insertionSort, SORT2_NAME);
    // return 0; // When initially testing your sort code, you may want to return here.

    // After sort code works on small array, test performance on bigArray.
    float duration = 0.0; // time in milliseconds
    // Startup code performs a single test run using the full size of bigArray
    duration = testSortAlgorithm1x(selectionSort, bigArray, BIGSIZE);
    cout << fixed << setprecision(2);
    cout << "\nSelection sort on bigArray took: "
         << setw(7) << duration << " milliseconds." << endl;

    duration = testLinearSearch(bigArray, BIGSIZE);
    cout << "Linear search  of bigArray took: "
         << setw(7) << duration << " milliseconds.\n";

    // Test the algorithms on many ever longer list of numbers. Only one array is needed.
    //  Lengths of 1000, 2000, 4000, 8000, 16000, 32000, 64000 are tested and displayed.
    testAlgorithms(bigArray, BIGSIZE);

    return 0;
} // end of main


// Add 2 sorts of your own. Document which sort you implemented
// My bubble sort
void bubbleSort(int array[], int size, bool verbose=false) {
    bool madeASwapThisPass;    //stores whether a swap was made in the current pass.
    int numberOfPasses = 1;     //Stores number of passes

    //Keep sorting through the array until no swaps are made.
    do {
        madeASwapThisPass = false;

        //The for loop looks through the unsorted portion of array.
        //At a very minimum, on each pass, the largest value on the end will be in the final sorted position
        for (int currentIndexCount = 0; currentIndexCount < size - numberOfPasses; currentIndexCount++) {
            //If the value of the currently indexed element is larger than the next element, then
            // the 2 should be switched
            if (array[currentIndexCount] > array[currentIndexCount + 1]) {
                //Print the elements before the swap
                if (verbose) {
                    cout << "    Before swap: array[" << currentIndexCount << "]=" << array[currentIndexCount]
                    << " > array[" << currentIndexCount + 1 << "]=" << array[currentIndexCount + 1] << endl;
                }
                //Swap the larger current element with the smaller next element
                int temporary = array[currentIndexCount];
                array[currentIndexCount] = array[currentIndexCount + 1];
                array[currentIndexCount + 1] = temporary;
                madeASwapThisPass = true;   //Set the made a swap to true so the do while loop will continue
                //Print the elements after the swap
                if (verbose) {
                    cout << "    After swap: array[" << currentIndexCount << "]=" << array[currentIndexCount]
                    << " < array[" << currentIndexCount + 1 << "]=" << array[currentIndexCount + 1] << endl << endl;
                }
            }
        }
        //Print the array after a pass
        if (verbose) {
            cout << "  After pass " << numberOfPasses << " the array is: ";
            showArray(array, size);
            cout << endl;
        }
        numberOfPasses++;

    //... Check the rest of the unsorted array as the unsorted portion grows smaller and smaller
    } while (madeASwapThisPass);
}

//My insertion sort
void insertionSort(int array[], int size, bool verbose=false) {
    //Iterate through the entire array once, starting from the second element, this will be the key
    for (int keyIndex = 1; keyIndex < size; keyIndex++) {
        //Store the value at the current key index and the index before
        int keyValue = array[keyIndex];
        int indexBefore = keyIndex - 1;
        if (verbose) cout << "    Current key value at array[" << keyIndex << "]=" << keyValue << endl;

        //Compare the key's value to the value of the element before it
        //If the key is smaller than element before, then we will shift the element before up 1 index and then
        //check the next previous element, repeating until the key can't move down any further
        while (indexBefore >= 0 && array[indexBefore] > keyValue) {
            if (verbose) {
                cout << "    Shifting array[" << indexBefore << "]=" << array[indexBefore]
                     << " up one position to array[" << indexBefore + 1 << "]" << endl;
            }
            //Shift the element up one position.
            array[indexBefore + 1] = array[indexBefore];
            indexBefore--; //Decrement indexBefore so we can check the next previous element
        }
        if (verbose) cout << "    Placing key value (" << keyValue << ") at array[" << indexBefore + 1 << "]\n";
        //After shifting all the previous elements greater than the key up, place the key value in the empty spot
        array[indexBefore + 1] = keyValue;
        //Print out the array after checking a key
        if (verbose) {
            cout << "\n  After checking key index " << keyIndex << " the array is: ";
            showArray(array, size);
            cout << endl;
        }
        //... Check the new element as the key
    }
}

// Your new search algorithm cannot be linear search, which is provided here.
bool linearSearchArray(int array[], int size, int target, int &position) {
    for (int i = 0; i < size; ++i)
        if (array[i] == target) // found it!
        {position=i; return true;}
    position = -1;
    return false;
}

//My binary search
bool binarySearchArray(int array[], int size, int target, int &position) {
    int lowestIndexBoundary = 0;    //Lower boundary of the portion of the array the target can be in
    int highestIndexBoundary = size - 1;    //Upper boundary of the portion of the array the target can be in
    bool found = false;     //Function returns whether the target is found
    position = -1;  //Position is -1 if the value can't be found
    //Look for the target while the boundaries aren't the same
    while (lowestIndexBoundary <= highestIndexBoundary) {
        int midpoint = (lowestIndexBoundary + highestIndexBoundary) / 2;

        //Check if the value at the midpoint of the array is the target, if so set position and set found to true
        //and stop searching
        if (array[midpoint] == target) {
            position = midpoint;
            found = true;
            break;
        //If the target is smaller than the midpoint, then search the lower half of the unsearched array
        } else if (array[midpoint] > target) {
            highestIndexBoundary = midpoint - 1;
        //If the target is larger than the midpoint, then search the upper half of the unsearched array
        } else {
            lowestIndexBoundary = midpoint + 1;
        }
    }
    return found;
}

// This is a selection sort from a concise algorithm encyclopedia.
// This code is VERY CRYPTIC! Not useful for learning. Not called.
// If your algorithms look like this, you will lose points!!!
void selectionSortConcise(int array[], int size) {
    int i, idx, val;
    for (i = 0; i < (size - 1); i++) {
        idx = i;
        val = array[i];
        for (int j = i + 1; j < size; j++) {
            if (array[j] < val) {
                val = array[j];
                idx = j;
            }
        }
        array[idx] = array[i];
        array[i] = val;
    }
}

// Your new sort algorithm cannot be selection sort, which is provided.
// This is the selection sort from our textbook, not called.
void selectionSortTextbook(int array[], int size) {
    int startScan, minIndex, minValue;
    for (startScan = 0; startScan < (size - 1); startScan++) {
        minIndex = startScan;
        minValue = array[startScan];
        for (int index = startScan + 1; index < size; index++) {
            if (array[index] < minValue) {
                minValue = array[index];
                minIndex = index;
            }
        }
        array[minIndex] = array[startScan];
        array[startScan] = minValue;
    }
}

// This selection sort is described in great detail, as you should do for this lab
// As an option, it displays details of its operation for each pass.
void selectionSort(int array[], int size, bool verbose=false) {
    int minIndexSoFar = 0, minValueSoFar{array[0]};
    for (int unsortedIndex = 0; unsortedIndex < (size - 1); unsortedIndex++) {
        // The outer loop looks at unsorted data, which is initially the whole array.
        // Gradually, a smaller and smaller portion of the array remains unsorted.
        minIndexSoFar = unsortedIndex;
        minValueSoFar = array[unsortedIndex];
        for (int seekMinIndex = unsortedIndex + 1; seekMinIndex < size; seekMinIndex++) {
            // the inner loop seeks the smallest value possible in the
            // remaining unsorted portion of the array.
            if (array[seekMinIndex] < minValueSoFar) {
                // found a smaller min value than before, save it for now
                if (verbose) cout << "  prev min in array[" << minIndexSoFar << "]=" << minValueSoFar;
                minValueSoFar = array[seekMinIndex];
                minIndexSoFar = seekMinIndex;
                if (verbose) cout << "; new min in array[" << minIndexSoFar << "]=" << minValueSoFar << endl;
            }
        }
        // The smallest value in the unsorted portion of the array has been found.

        if (verbose) {
            cout << "  swap left in array[" << unsortedIndex << "]=" << array[unsortedIndex];
            cout << " with min in array[" << minIndexSoFar << "]=" << array[minIndexSoFar] << endl;
        }

        // Swap the original left-most unsorted value with minimum value which was just found.
        array[minIndexSoFar] = array[unsortedIndex];
        array[unsortedIndex] = minValueSoFar;

        if (verbose) {
            cout << "  After pass " << unsortedIndex << " the array is: ";
            showArray(array, size);
            cout << endl;
        }
        // ... continue seeking the minimum value in the smaller remaining portion.
    }
}

/* !!! PROVIDE TESTING OUTPUT WITH YOUR OWN TEST RESULTS !!!
Test sorting algorithms on small array:

selection sort start: smallArray is:  7 9 3 1 8 6 2
  prev min in array[0]=7; new min in array[2]=3
  prev min in array[2]=3; new min in array[3]=1
  swap left in array[0]=7 with min in array[3]=1
  After pass 0 the array is:  1 9 3 7 8 6 2

  prev min in array[1]=9; new min in array[2]=3
  prev min in array[2]=3; new min in array[6]=2
  swap left in array[1]=9 with min in array[6]=2
  After pass 1 the array is:  1 2 3 7 8 6 9

  swap left in array[2]=3 with min in array[2]=3
  After pass 2 the array is:  1 2 3 7 8 6 9

  prev min in array[3]=7; new min in array[5]=6
  swap left in array[3]=7 with min in array[5]=6
  After pass 3 the array is:  1 2 3 6 8 7 9

  prev min in array[4]=8; new min in array[5]=7
  swap left in array[4]=8 with min in array[5]=7
  After pass 4 the array is:  1 2 3 6 7 8 9

  swap left in array[5]=8 with min in array[5]=8
  After pass 5 the array is:  1 2 3 6 7 8 9

selection sort stop:  smallArray is:  1 2 3 6 7 8 9
Verified: smallArray is sorted.

bubble sort start: smallArray is:  7 9 3 1 8 6 2
    Before swap: array[1]=9 > array[2]=3
    After swap: array[1]=3 < array[2]=9

    Before swap: array[2]=9 > array[3]=1
    After swap: array[2]=1 < array[3]=9

    Before swap: array[3]=9 > array[4]=8
    After swap: array[3]=8 < array[4]=9

    Before swap: array[4]=9 > array[5]=6
    After swap: array[4]=6 < array[5]=9

    Before swap: array[5]=9 > array[6]=2
    After swap: array[5]=2 < array[6]=9

  After pass 1 the array is:  7 3 1 8 6 2 9

    Before swap: array[0]=7 > array[1]=3
    After swap: array[0]=3 < array[1]=7

    Before swap: array[1]=7 > array[2]=1
    After swap: array[1]=1 < array[2]=7

    Before swap: array[3]=8 > array[4]=6
    After swap: array[3]=6 < array[4]=8

    Before swap: array[4]=8 > array[5]=2
    After swap: array[4]=2 < array[5]=8

  After pass 2 the array is:  3 1 7 6 2 8 9

    Before swap: array[0]=3 > array[1]=1
    After swap: array[0]=1 < array[1]=3

    Before swap: array[2]=7 > array[3]=6
    After swap: array[2]=6 < array[3]=7

    Before swap: array[3]=7 > array[4]=2
    After swap: array[3]=2 < array[4]=7

  After pass 3 the array is:  1 3 6 2 7 8 9

    Before swap: array[2]=6 > array[3]=2
    After swap: array[2]=2 < array[3]=6

  After pass 4 the array is:  1 3 2 6 7 8 9

    Before swap: array[1]=3 > array[2]=2
    After swap: array[1]=2 < array[2]=3

  After pass 5 the array is:  1 2 3 6 7 8 9

  After pass 6 the array is:  1 2 3 6 7 8 9

bubble sort stop:  smallArray is:  1 2 3 6 7 8 9
Verified: smallArray is sorted.

insertion sort start: smallArray is:  7 9 3 1 8 6 2
    Current key value at array[1]=9
    Placing key value (9) at array[1]

  After checking key index 1 the array is:  7 9 3 1 8 6 2

    Current key value at array[2]=3
    Shifting array[1]=9 up one position to array[2]
    Shifting array[0]=7 up one position to array[1]
    Placing key value (3) at array[0]

  After checking key index 2 the array is:  3 7 9 1 8 6 2

    Current key value at array[3]=1
    Shifting array[2]=9 up one position to array[3]
    Shifting array[1]=7 up one position to array[2]
    Shifting array[0]=3 up one position to array[1]
    Placing key value (1) at array[0]

  After checking key index 3 the array is:  1 3 7 9 8 6 2

    Current key value at array[4]=8
    Shifting array[3]=9 up one position to array[4]
    Placing key value (8) at array[3]

  After checking key index 4 the array is:  1 3 7 8 9 6 2

    Current key value at array[5]=6
    Shifting array[4]=9 up one position to array[5]
    Shifting array[3]=8 up one position to array[4]
    Shifting array[2]=7 up one position to array[3]
    Placing key value (6) at array[2]

  After checking key index 5 the array is:  1 3 6 7 8 9 2

    Current key value at array[6]=2
    Shifting array[5]=9 up one position to array[6]
    Shifting array[4]=8 up one position to array[5]
    Shifting array[3]=7 up one position to array[4]
    Shifting array[2]=6 up one position to array[3]
    Shifting array[1]=3 up one position to array[2]
    Placing key value (2) at array[1]

  After checking key index 6 the array is:  1 2 3 6 7 8 9

insertion sort stop:  smallArray is:  1 2 3 6 7 8 9
Verified: smallArray is sorted.


Selection sort on bigArray took: 4405791.00 milliseconds.
Linear search  of bigArray took:  134.10 milliseconds.
Algorithm               1000        2000        4000        8000       16000       32000       64000
================     =======     =======     =======     =======     =======     =======     =======
selection sort       1099.00     4291.00    16949.00    67581.00   269104.00  1074835.00  4295091.00
bubble sort          1434.00     5446.00    22115.00    99806.00   499946.00  2236387.00  9421042.00
insertion sort        589.00     2328.00     9383.00    36807.00   149220.00   600245.00  2395681.00
--------
linear search           2.12        4.18        8.37       16.73       33.43       66.88      134.21
binary search           0.07        0.07        0.08        0.08        0.09        0.10        0.10

Process finished with exit code 0

*/
