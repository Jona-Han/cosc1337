/*
  Author:                      Name
  Assignment Number:           Lab 9
  File Name:                   DLS_L9_Lastname.cpp
  Course/Section:              COSC 1337 Section xx
  Due Date:                    See syllabus or blackboard
  Instructor:                  Thayer
*/

/*
Lab Ch09
  To find places to add code, search on "<add code>"
  To find places to change code, search on "<change code>"
  To find either places, search on "code>"
*/

#include <iostream>
#include <iomanip>
#include <random> // needed for Orwell devcpp

using namespace std;

// The searching and sorting algorithms will be tested on a big array filled with random numbers.
// To test on various array sizes, increasing amounts of the big array will be used.
// A table will display results of how long it takes to complete a task on various sizes of test data.
const int BIGSIZE = 64000;
int bigArray[BIGSIZE];
const int testSizes[] = {1000, 2000, 4000, 8000, 16000, 32000, BIGSIZE, 0}; // 0 is a sentinel
// All numbers inside testSizes MUST BE less than or equal to BIGSIZE

const int TARGET = 123456789; // TARGET is uses as a number to search for.
// TARGET cannot be found. It is larger than any random number
// generated by rand(), as desired to test for worst-case performance of search.

// array helper functions:
void showArray(int array[], int size, const string &msg="") { // displays every element in array
  cout<<msg;
  for (int i{}; i<size; ++i)
    cout << setw(2) << array[i]; // assumes small numbers
  cout << endl;
}

// Useful to verify that array is really sorted!
bool verifySorted(int array[], int size) {
  // returns true if array is in ascending order, else false.
  for (int i=0; i<(size-1); ++i)
    if (array[i]>array[i+1]) return false;
  return true;
}


// Useful to measure unsorted-ness of the array
int unorderedCount(int array[], int size) {
  // returns count of out of order adjacent pairs.
  int unsorted_adjacent_pairs{};
  for (int i=0; i<(size-1); ++i)
    if (array[i]>array[i+1]) ++unsorted_adjacent_pairs;
  return unsorted_adjacent_pairs;
}

// To display the table of timing results, use these to set column widths:
const int AlgorithmNameMaxWidth=16; // maximum column width to display algorithm names
const int TestSizeWidth=12;         // maximum column width to display time to run algorithms
const int DurationWidth=TestSizeWidth;
// Adjust these column widths if/as needed so the table columns are aligned.

// Each selection sort below does the same algorithm. The difference is in
// how well it documents its operation. See code after main.
const string SELECTION_SORT_NAME{"selection sort"};
void selectionSortConcise(int[], int);   // from internet, not called
void selectionSortTextBook(int[], int);  // from our textbook, not called
void selectionSort(int[], int, bool);    // as expected for this lab

// <change code> Change "mySort1", "mySort2" to better names that match sort algorithm
const string SORT1_NAME {"my sort 1"};
void mySort1(int[], int, bool);    // expected for this lab <change code>

const string SORT2_NAME {"my sort 2"};
void mySort2(int[], int, bool);    // expected for this lab <change code>

bool linearSearchArray(int [], int, int, int&); // provided
bool binarySearchArray(int [], int, int, int&); // expected for this lab <change code>

// This code helps to automate multiple test runs.

// Call this code as many times as desired to test your sort algorithms.
float testSortAlgorithm1x(void sortAlgorithm(int [], int, bool),
                          int array[], int arraySize, bool verbose=false) {
  // Run sortAlgorithm once on array and return time elapsed in milliseconds.
  // This function is interesting. The first parameter is a "function pointer",
  // It accepts any function that returns a void and has parameters of type: (int [], int, bool)
  // The first parameter (in the caller) can be the name of a function being tested.
  // This reduces redundant code. The same sequence of tests are performed on each
  // sort function. (Our textbook does not mention function pointers.)
  
  // fill array with random, unsorted numbers to be sorted
  for (int index = 0; index < arraySize; index++)
    array[index] = rand();  // initialize array with random values
  int startTime = clock();  // get the start time, in milliseconds
  sortAlgorithm(array, arraySize, verbose);  // ALGORITHM UNDER TEST
  int stopTime = clock();   // get the stop time, in milliseconds
  float duration = stopTime - startTime;
  
  int unordered_pairs = unorderedCount(array, arraySize);
  if (unordered_pairs != 0)
    return -unordered_pairs; // return a negative count of unordered pairs to indicate sort failure
  else
    return duration;
}

void testSortAlgorithmNx(void sortAlgorithm(int [], int, bool), string sortName,
                         int array[], int arraySize, bool verbose=false) {
  // call testSortAlgorithm1x for each size in testSizes; display results on one line of table
  cout << endl << setw (AlgorithmNameMaxWidth) << left << sortName;
  for (int testCount=0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
    cout << setw(DurationWidth) << right << testSortAlgorithm1x(sortAlgorithm, array, testSizes[testCount]);
}
                        

// Copy/paste/modify/reuse this code as desired to test search algorithms.
// Because search is much faster than sort and duration is in milliseconds,
// the search is run retry times (defaults to 1000) and duration is divided by retry.
float testLinearSearch(int array[], int arraySize, int retry=1000) {
  bool found = false; // true if TARGET is found in array
  int foundAt = -1;    // index in array where TARGET was found
  int startTime = clock();
  for (int repeat = 0; repeat < retry; ++repeat) // repeat test 1000 times to increase duration
    found = linearSearchArray(array, arraySize, TARGET, foundAt); // ALGORITHM UNDER TEST
  int stopTime = clock();
  float duration = stopTime - startTime;
  return duration/retry; // divide duration by 1000 to get time for single search
}

// <add code> to test binary search. It works like testLinearSearch
float testBinarySearch(int array[], int arraySize, int retry=1000) {
  // <add code> to return the duration of performing a binary search
  // You can reuse the code for testLinearSearch, but call binarySearchArray
  // Your parameters to call binarySeachArray may be different than linearSearchArray.

  return 0.0;
}

void testAlgorithms(int array[], int arraySize, bool verbose=false) {
  // This draws a table of results for each algorithm tested.
  // Initially, the heading for the table is displayed:
  cout << setw (AlgorithmNameMaxWidth) << left << "Algorithm";
  for (int testCount=0; testSizes[testCount]; ++testCount)
    cout << setw(TestSizeWidth) << right << testSizes[testCount];
  cout << endl << string(AlgorithmNameMaxWidth, '=');
  for (int testCount=0; testSizes[testCount]; ++testCount)
    cout << setw(DurationWidth) << right << " =======";
    
  // In testSortAlgorithmNx, the name of the sort function is passed as a parameter.
  // Do the same thing for your sort algorithms. It works as long as your sort algorithm
  // returns void and is declared as: void sort(int array[], int size).
  
  testSortAlgorithmNx(selectionSort, SELECTION_SORT_NAME, array, arraySize); // provided
  // call to test your first sort algorithm. <change code> rename my sort 1
  testSortAlgorithmNx(mySort1, SORT1_NAME, array, arraySize);
  // call to test your second sort algorithm. <change code> rename my sort 2
  testSortAlgorithmNx(mySort2, SORT2_NAME, array, arraySize);

  cout<<"\n--------"; // separator between sort algorithms and search algorithms
  
  // Here, the provided linear search is tested...
  cout << endl << setw (AlgorithmNameMaxWidth) << left << "linear search";
  for (int testCount=0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
    cout << setw(DurationWidth) << right << testLinearSearch(array, testSizes[testCount]);

  // <change code> Use a loop to call and test your search algorithm here
  cout << endl << setw (AlgorithmNameMaxWidth) << left << "binary search";
  for (int testCount=0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
    cout << setw(DurationWidth) << right << testBinarySearch(array, testSizes[testCount]);
  cout << endl;
}


void testSortOnSmallArray(void sortAlgorithm(int [], int, bool), string sortName) {
  int smallArray[] {7, 9, 3, 1, 8, 6, 2}; // for testing purposes

  const int SMALLSIZE = sizeof(smallArray)/sizeof(smallArray[0]);
  
  showArray(smallArray, SMALLSIZE, sortName + " start: smallArray is: ");
  sortAlgorithm(smallArray, SMALLSIZE, true); // true means verbose, show details
  showArray(smallArray, SMALLSIZE, sortName + " stop:  smallArray is: ");
  cout << ((verifySorted(smallArray, SMALLSIZE)) ?
    "Verified: smallArray is sorted.\n\n" :
    "Oops!!!: smallArray is NOT sorted.\n\n");
}

int main () {
  srand(time(0));  // seed the random number generator only once.

  // When first implementing your algorithm, test it on a very small array.
  // The verbose flag will be set to true in testSortOnSmallArray, so step-by-step
  // progress will be displayed. This describes how the sort is working.

  cout << "Test sorting algorithms on small array:\n\n";
  // testSortOnSmallArray provides a small array to test on and sets verbose=true
  testSortOnSmallArray(selectionSort, SELECTION_SORT_NAME);
  testSortOnSmallArray(mySort1, SORT1_NAME);
  testSortOnSmallArray(mySort2, SORT2_NAME);
  // return 0; // When initially testing your sort code, you may want to return here.
  
  // After sort code works on small array, test performance on bigArray.
  float duration = 0.0; // time in milliseconds
  // Startup code performs a single test run using the full size of bigArray
  duration = testSortAlgorithm1x(selectionSort, bigArray, BIGSIZE);
  cout << fixed << setprecision(2);
  cout << "\nSelection sort on bigArray took: "
       << setw(7) << duration << " milliseconds." << endl;

  duration = testLinearSearch(bigArray, BIGSIZE);
  cout << "Linear search  of bigArray took: "
       << setw(7) << duration << " milliseconds.\n\n";

  // Test the algorithms on many ever longer list of numbers. Only one array is needed.
  //  Lengths of 1000, 2000, 4000, 8000, 16000, 32000, 64000 are tested and displayed.
  testAlgorithms(bigArray, BIGSIZE);

  return 0;
} // end of main

// Add 2 sorts of your own. Document which sort you implemented
// <add code> Add your first sort algorithm in here
void mySort1(int array[], int size, bool verbose=false) {
  // if verbose is set to true, display (cout) step-by-step progress of sort
  if (verbose) {
    cout << "  "<< SORT1_NAME <<" has not been implemented.\n";  // replace when implemented
    // if no step-by-step progress is displayed when verbose is true, points reduced!
  }
  // doesn't do anything! <add code>
}

// <add code> Add your second sort algorithm in here
void mySort2(int array[], int size, bool verbose=false) {
  // if verbose is set to true, display (cout) step-by-step progress of sort
  if (verbose) {
    cout << "  "<< SORT2_NAME <<" has not been implemented.\n";  // replace when implemented
    // if no step-by-step progress is displayed when verbose is true, points reduced!
  }
  // doesn't do anything! <add code>
}

// Your new search algorithm cannot be linear search, which is provided here.
bool linearSearchArray(int array[], int size, int target, int &position) {
  for (int i = 0; i < size; ++i)
    if (array[i] == target) // found it!
      {position=i; return true;}
  position = -1;
  return false;
}

bool binarySearchArray(int array[], int size, int target, int &position) {
  // Your binary search does not have to have exactly the same declaration
  // but it should include: array, size, target, return value
  // doesn't do anything! <add code>
}

// This is a selection sort from a concise algorithm encyclopedia.
// This code is VERY CRYPTIC! Not useful for learning. Not called.
// If your algorithms look like this, you will lose points!!!
void selectionSortConcise(int array[], int size) {
  int i, idx, val;
  for (i = 0; i < (size - 1); i++) {
    idx = i;
    val = array[i];
    for (int j = i + 1; j < size; j++) {
      if (array[j] < val) {
        val = array[j];
        idx = j;
      }
    }
    array[idx] = array[i];
    array[i] = val;
  }
}

// Your new sort algorithm cannot be selection sort, which is provided.
// This is the selection sort from our textbook, not called.
void selectionSortTextbook(int array[], int size) {
  int startScan, minIndex, minValue;
  for (startScan = 0; startScan < (size - 1); startScan++) {
    minIndex = startScan;
    minValue = array[startScan];
    for (int index = startScan + 1; index < size; index++) {
      if (array[index] < minValue) {
        minValue = array[index];
        minIndex = index;
      }
    }
    array[minIndex] = array[startScan];
    array[startScan] = minValue;
  }
}

// This selection sort is described in great detail, as you should do for this lab
// As an option, it displays details of its operation for each pass.
void selectionSort(int array[], int size, bool verbose=false) {
  int minIndexSoFar = 0, minValueSoFar{array[0]};
  for (int unsortedIndex = 0; unsortedIndex < (size - 1); unsortedIndex++) {
    // The outer loop looks at unsorted data, which is initially the whole array.
    // Gradually, a smaller and smaller portion of the array remains unsorted.
    minIndexSoFar = unsortedIndex;
    minValueSoFar = array[unsortedIndex];
    for (int seekMinIndex = unsortedIndex + 1; seekMinIndex < size; seekMinIndex++) {
      // the inner loop seeks the smallest value possible in the
      // remaining unsorted portion of the array.
     if (array[seekMinIndex] < minValueSoFar) {
        // found a smaller min value than before, save it for now
        if (verbose) cout << "  prev min in array[" << minIndexSoFar << "]=" << minValueSoFar;
        minValueSoFar = array[seekMinIndex];
        minIndexSoFar = seekMinIndex;
        if (verbose) cout << "; new min in array[" << minIndexSoFar << "]=" << minValueSoFar << endl;
      }
    }
    // The smallest value in the unsorted portion of the array has been found.

    if (verbose) {
      cout << "  swap left in array[" << unsortedIndex << "]=" << array[unsortedIndex];
      cout << " with min in array[" << minIndexSoFar << "]=" << array[minIndexSoFar] << endl;
    }

    // Swap the original left-most unsorted value with minimum value which was just found.
    array[minIndexSoFar] = array[unsortedIndex];
    array[unsortedIndex] = minValueSoFar;

    if (verbose) {
      cout << "After pass " << unsortedIndex << " the array is: ";
      showArray(array, size);
      cout << endl;
    }
    // ... continue seeking the minimum value in the smaller remaining portion.
  }
}

/* !!! PROVIDE TESTING OUTPUT WITH YOUR OWN TEST RESULTS !!!

*/
